# < 11. Tempus Fugit — Mach Scheduling >

제 10 장에서 설명한 핵심 기본에 따라 Mach는 많은 중요한 기능을 제공합니다. 그 대부분은 시스템 자원 (하드웨어 장치, 가상 메모리, CPU 자체) 관리를 중심으로 전개하고 있습니다. CPU 관리는 CPU를 위해 경쟁하는 많은 프로그램 중 언제 어떤 CPU를 사용할 것인지 결정하는 작업을 나타내므로 스케줄링이라고도합니다.

> Scheduling Primitives: 작업 및 스레드와 이들이 제공하는 API (응용 프로그래밍 인터페이스)에 대해 설명합니다.

> Scheduling: 알고리즘과 같은 높은 수준의 스케줄링 개념에 대해 논의합니다.

> Asynchronous Software Traps (ASTs): 스케줄링에 중요한 Mach의 AST 개념에 대해 설명합니다.

> Exception Handling: 하드웨어 트랩(예외)에 대한 마하의 고유 한 접근 방식에 대해 논의하십시오.

> Scheduling Algorithms: Mach의 기본 스레드 스케줄러의 세부 내용과 스케줄러를 확장하거나 다른 알고리즘 구현으로 대체 할 수 있는 스케줄링 프레임 워크를 포함합니다.

## SCHEDULING PRIMITIVES (스케줄링 기본사항)

모든 최신 운영 체제와 마찬가지로 커널은 프로세스가 아닌 스레드를 봅니다. 실제로 Mach는 UNIX와 마찬가지로 프로세스 개념을 인식하지 못합니다. 프로세스보다는 가벼운 task의 개념을 사용하여 약간 다른 접근 방식을 사용합니다. Classic UNIX는 top-down(하향식 접근 방식)을 사용하는데, 기본 오브젝트는 하나 이상의 스레드로 더 나누어지는 프로세스입니다. 반면 Mach은 기본 단위가 스레드이고 하나 이상의 스레드가 작업에 포함 된 bottom-up(상향식 접근 방식)을 사용합니다.

## Threads

스레드는 Mach의 원자 단위 실행을 정의합니다. 스레드는 기본 시스템 레지스터 상태 및 다양한 스케줄링 통계를 나타냅니다. kern/thread.h에 정의된 스레드는 가능한 가장 낮은 오버 헤드를 유지하면서 스케줄링에 필요한 최대 정보를 제공하도록 설계되었습니다. (목록 11-1 참조)

![11-1](../img/chapter11/11_11_1.PNG)

![11-2](../img/chapter11/11_11_2.PNG)

![11-3](../img/chapter11/11_11_3.PNG)

![11-4](../img/chapter11/11_11_4.PNG)

![11-5](../img/chapter11/11_11_5.PNG)

앞의 구조는 엄청 나기 때문에 대부분의 스레드는 일반 템플릿을 복제하여 만들어지며,이 구조는 기본값으로 구조를 채웁니다. 이 템플릿은 osfmk/thread/thread.c에 정의된 thread_template입니다. 커널 부트 (i386_init에서)이라고 불리는 thread_bootstrap() 의해 채워지며 thread_create () Mach API를 구현하는 thread_create_internal ()에서 복사됩니다.

관심있는 특정 필드 중 하나는 uthread 멤버이며, 이는 BSD 계층에 대한 void 포인터입니다. 이 멤버는 BSD 유저 스레드를 가리킵니다. 이 스레드는 Mach에 대해 불투명하고 이 장에서와 같이 불투명합니다.(??)

기타 필드로 가득 차 있지만 스레드에는 실제 자원 참조가 없습니다. Mach는 작업을 스레드 컨테이너로 정의하며 리소스를 처리하는 작업 수준입니다. 스레드는 포함 태스크에 할당 된 자원 및 메모리에만 포트를 통해 액세스 할 수 있습니다.

## Tasks

작업은 가상 메모리 공간과 리소스가 관리되는 컨테이너 개체 역할을합니다. 이러한 리소스는 장치 및 기타 핸들입니다. 게다가 포트에 의해 리소스는 추상화됩니다. 따라서 자원을 공유하면 해당 포트에 대한 액세스를 제공해야합니다. 

엄밀히 말하면 task는 다른 운영 체제가 프로세스 부르는 것이 아닙니다. Mach 마이크로 커널은 프로세스 로직을 제공하지 않고, 최소한의 구현만을 제공합니다. 그러나 BSD 모델에서는 두 개념 사이에 간단한 1대1의 매핑이 존재하며 모든 BSD (및 OS X) 프로세스에는 이와 관련된 Mach Task Object가 있습니다. 이 매핑은 Mach가 전혀 눈치 채지 못한 채 불투명 한 포인터 bsd_info을 지정하여 수행됩니다. Mach는 Task로 커널을 나타냅니다(글로벌 kernel_task라고합니다). 이 작업에 해당하는 PID가 없습니다 (기술적으로는 PID 0 생각할 수 있습니다).

Task는 목록 11-2에 표시된 것처럼 osfmk/kern/task.h에 정의된 비교적 가벼운 구조(적어도 스레드와 비교하여)입니다. 주목할만한 필드가 강조됩니다.

![11-6](../img/chapter11/11_11_6.PNG)

![11-7](../img/chapter11/11_11_7.PNG)

![11-8](../img/chapter11/11_11_8.PNG)

Task 자체에는 생명이 없습니다. 그것은 하나 이상의 스레드의 컨테이너 역할을합니다. Task의 스레드는 이전 코드에서 강조 표시된대로 thread_count 스레드를 포함하는 큐인 스레드 멤버에서 유지 보수됩니다.

또한 Task에 대한 대부분의 operation은 실제로 주어진 Task의 모든 스레드에 대해 동일한 해당 스레드 작업의 반복입니다. 예를 들어, 작업 우선 순위를 설정하기 위해 task_ priority ()가 목록 11-3과 같이 구현됩니다.

![11-9](../img/chapter11/11_11_9.PNG)

queue_iterate 매크로는 queue_head_t를 반복합니다. 차례로 각 스레드가 잠깁니다. 활성화 된 경우 우선 순위를 설정할 수 있습니다. 그런 다음 스레드를 잠금 해제 할 수 있습니다

### Task - Ledgers

Ledgers는 할당량을 부여하고 Mach작업에 대한 제한을 설정하는 메커니즘을 제공합니다. 이것은 POSIX에서 제공하는 getrlimit (2) / setrlimit (2) 시스템 호출과 다소 유사하지만 보다 향상된 자원 조절 기능을 제공합니다. 자원 (일반적으로 CPU 및 메모리)은 Ledgers 간에 전송 될 수 있으며 한계를 초과하면 콜백을 실행하는 Mach exception이 발생하거나 Ledger가 리필될 때까지 스레드를 막게 됩니다.

Ledgers는 Mach가 시작된 이래로 존재했지만 최근 XNU에서만 구현되었습니다. 실제로, 그들은 iOS에서 데뷔 한 Mountain Lion으로서만 공식적으로 지원 될 것입니다. Lion 커널 소스에는 osfmk/kern/ledger.c 파일이 있지만 파일에 대한 의견은 "기능 장애" Ledgers에 대한 "반쯤 마비 된 시도"일 뿐이며 root_wired_ledger 및 root_paged_ledger Ledgers만 제공합니다. 둘 다 (ledger_init에 의해) 무제한으로(LEDGER_ITEM_INFINITY) 초기화되므로 시스템은 추적을 유지하지만 유선 및 페이징 메모리에 제한을 두지 않습니다.

새로운 BSD 시스템 콜(Ledger라고 함)은 현재 문서화되어 있지 않지만 iOS에서는 지원되며 Mountain Lion에서도 지원 될 것입니다. 이 호출은 각각 0, 1, 2의 코드에 대해 ledger_info (), ledger_entry_info (), ledger_template_info ()를 의미하고 기본 Mach API에 대한 BSD 브리지입니다. 문서화되지 않은 상태로 남아 있습니다. 이를 통해 Task별로 Ledgers를 사용할 수 있으므로 CPU 및 메모리와 같은 시스템 리소스를보다 강력하게 제어 할 수 있습니다.

## Task and Thread APIs

지금까지 제시된 task_t 및 thread_t의 구조는 풍부합니다. 구조는 거대하고 대부분의 커널 API가 최소한 직접적으로 액세스 할 필요가 없는 정도로 많은 세부 사항을 포함합니다. 또 다른 문제는 커널 버전간에 구조가 변경 될 수 있다는 것입니다. 다행히도 Mach에는 객체 지향 방식으로 작업과 스레드에서 사용할 수있는 다양한 API 호출이 포함되어있어 실제 구현은 불투명합니다. get_bsdthread_info (), get_bsdtask_info (), get_bsdthreadtask_info () 등과 같은 중요한 필드에 특정 접근자 함수를 사용할 수 있으며 사용해야합니다. 또한이 섹션의 다음 부분에서 설명하는 task 및 스레드 "method"에 해당하는 API를 사용할 수 있습니다.

### Task and Thread APIs - Getting the Current Task and Thread

커널은 현재 작업과 현재 스레드의 핸들을 얻을 수 있어야 합니다. current_task ()와 current_thread ()의 두 함수를 통해 이를 수행합니다. 함수는 각각 osfmk/kern/task.h 및 osfmk/kern/thread.h에 정의되어 있지만 실제로는 아키텍처 종속 변형에 대한 래퍼입니다. 두 기능 모두 "fast"기능에 대한 매크로입니다. 두 가지 작업에 관련된 트릭은 current_thread(), 즉 current_thread_fast()를 얻는 것입니다. current_task()는 단순히 현재 스레드의 작업 필드를 반환하여 검색 할 수 있기 때문입니다 (실제로 current_task_fast ()는 current_thread ()-> 태스크에 대해 정의됩니다).

XNU 소스를 살펴보면 current_thread() (osfmk/i386/machine_routines.c 및 osfmk/i386/cpu_data.h의 매크로)가 current_thread_ fast()를 래핑하고 get_active_thread()에 대해 #defined를 찾게됩니다. get_ active_thread () 구현은 인라인 어셈블리 (GS 레지스터에 의존) 인 CPU_DATA_GET (cpu_active_thread, thread_t)를 래핑합니다. iOS에서 어셈블리 호출은 ARM 보조 프로세서의 특수 레지스터 c13을 사용합니다.

## Task APIs

Mach는 Task를 처리하기 위한 하위 시스템 기능을 제공합니다. 사용자 모드에 노출 된 API는 <mach / task.h>에 있으며 여기에는 아키텍처 헤더 (예 : <mach / i386 / task.h>)가 있습니다. 

표 11-1에는 이러한 기능이 자세히 나와 있으며, 이 기능은 모두 Mach 메시지(MIG 하위 시스템 3400)를 통해 구현됩니다.

![11-10](../img/chapter11/11_11_10.PNG)

![11-11](../img/chapter11/11_11_11.PNG)

작업 포트는 작업, 해당 스레드 및 리소스를 완벽하게 제어 할 수있는 경로입니다. 위의 표에 표시된 API는 Mach가 작업에서 허용하는 작업 중 일부일뿐입니다. 다음 섹션에서는 작업 스레드를 외부에서 조작하는 방법을 보여줍니다. 이러한 기능은 kernel_task에 적용될 때 상당히 강력 해집니다. 권한있는 사용자가 커널 메모리를 들여다보고 수정할 수 있습니다.

### Task APIs - Experiment: Using the Task APIs

task_info 사용하면 10-19처럼 확장하는 것이 가능하고 Task에 대한 세부 정보를 제공할 수 있습니다. task_info의 두 번째 매개 변수는 요청된 정보 유형을 지정하는 task_flavor_t입니다. 특징은 다소 변동성이 있으며 버전마다 변경하면 타사가 진단에 의존하기가 어려울 수 있습니다.

그러나 재컴파일의 위험(부적절하고 쓸모없는 상수를 다루는 것)을 통해 이러한 API가 제공하는 많은 진단 정보을 얻을 수 있습니다. task_info의 top을 통해 터미널 창 크기가 허용 화면을 통해 매우 상세하고 마하 특정 정보를 얻을 수 있습니다.

Listing 11-4는 task_info를 사용하여 Lion 이상에서 지원되는 일부 기능을 쿼리하는 방법을 보여줍니다.

![11-12](../img/chapter11/11_11_12.PNG)

![11-13](../img/chapter11/11_11_13.PNG)

![11-14](../img/chapter11/11_11_14.PNG)

이 함수를 Listing 10-19에 연결하는 것은 간단하다. 이 실험과 유사한 방식으로 thread_info () 함수를 사용하여 스레드 레벨까지 드릴 다운 할 수 있습니다. 이것은 다음에 논의되는 많은 스레드 API 중 하나입니다.

## Thread APIs

Mach는 Task와 마찬가지로 스레드 관리를 위한 풍부한 API를 제공합니다. 이들 대부분은 Task와 동일한 기능을 수행합니다. 실제로 task API는 종종 각 task의 스레드 목록을 반복하여 차례로 적용합니다. 예상 할 수 있듯이, 이러한 호출 (mach_ thread_self 제외)은 Mach 메시지를 통해 구현되며 MIG 하위 시스템 (3600)에 의해 생성됩니다. 표 11-3에는 스레드 API가 나열되어 있습니다. 별다른 언급이없는 한 모두는 kern_return_t를 반환합니다.

![11-15](../img/chapter11/11_11_15.PNG)

![11-16](../img/chapter11/11_11_16.PNG)

실습으로, 이전 실험에서 목록을 확장하여 스레드도 나열 할 수 있습니다. 이는 태스크 포트에서 task_threads ()를 호출하고 리턴된 각 스레드 포트에서 thread_info(THREAD_ BASIC_INFO 사용)를 호출하여 수행 할 수 있습니다.

### Thread APIs - In-Kernel Thread APIs

Mach는 커널 모드에서만 액세스 할 수 있는 일련의 스레드 제어 기능을 제공합니다. 이들은 osfmk/kern/sched_prim.h에 선언되어 있으며 이들 중 일부는 표 11-4에 나와 있습니다.

![11-17](../img/chapter11/11_11_17.PNG)

![11-18](../img/chapter11/11_11_18.PNG)

### Thread APIs - Thread Creation

스레드 생성 API가 특히 중요합니다. 포함되는 task의 외부에 스레드가 존재할 수 없고 API는 task.h에 구현되어 있습니다.

![11-19](../img/chapter11/11_11_19.PNG)

첫 번째 인수를 주목하십시오. task_t는 스레드가 생성 될 작업입니다. 이것은 마하의 관점에서 사용자가 해당 포트가있는 모든 작업에서 스레드를 만들 수 있음을 의미합니다. 이는 Mach 인프라가 원격 스레드를 생성 할 수 있는 유연성을 제공합니다. 따라서 pthread_create()를 사용하면 mach_task_self()를 첫 번째 인수로 사용하여 Mach의 thread_create에 대한 기본 API 호출이 발생합니다. 그러나 다른 task 포트가 있으면 스레드를 삽입 할 수 있습니다. 주입 된 스레드가 작업의 가상 메모리에 대한 전체 액세스 권한을 획득하고 감지하기가 매우 어려우므로 올바른 (또는 잘못된)기능이 구현 될 수 있습니다.

스레드를 만드는 것은 간단하지만 의미있는 일을 하는 것은 조금 더 복잡합니다. 우선, 외부 작업에 코드를 삽입하려면 mach_vm_write API를 사용하여 일반적으로 “자신의 코드"를 가져와야합니다. 그런 다음 thread_set_state (표 11-3 참조)를 사용하여 스레드의 레지스터 상태를 초기화하여 제공된 코드를 로드하고 실행해야 합니다. 그러나 이러한 모든 API는 작업 포트가 있으면 API가 모두 작동하므로 간단합니다.

## SCHEDULING

시스템의 CPU (또는 코어) 수에 관계없이 스레드는 반드시 CPU 수를 능가합니다. 따라서 커널은 CPU에서 스레드를 다룰 수 있어야 하고, 사람 사용자가 동시성으로 인식하는 방식으로 많은 스레드를 실행할 수 있습니다. 그러나 실제로 각 코어는 한 번에 하나의 스레드만 실행할 수 있기 때문에 커널은 스레드 하나를 선점하고 다른 스레드로 교체하여 스레드간에 컨텍스트 전환을 수행 할 수 있어야합니다.

 멀티 프로세싱이 이제 일반화되었으며 하이퍼 스레딩, 다중 코어 및 다중 프로세서와 같은 다양한 기술을 하드웨어 수준에서 사용하여 이 기능을 사용할 수 있습니다. 커널의 관점에서 볼 때 각 기술에는 장점과 단점이 있지만 위에서 언급한 기술 간에는 실질적인 차이가 없습니다. 하이퍼 스레딩, 2 개의 코어 또는 2 개의 별개의 CPU를 사용하든 대부분의 운영 체제에는 2개의 논리 프로세서가 있습니다.
 
 하이퍼스레딩 : 인텔이 구현한 동시 멅티스레딩 기술

procesor-set 추상화를 통해 Mach는 Linux 또는 Windows보다 다소 적합하며 실제로 동일한 pset에서 동일한 CPU의 코어를 관리하고 별도의 pset에서 개별 CPU를 관리 할 수 있습니다. 이 섹션의 나머지 부분에서는 사례를 구분하지 않으며 실제 CPU가 아니라 논리적 CPU에 CPU라는 용어를 사용합니다.

## The High-Level View

컨텍스트 전환은 레지스터 상태를 사전 정의 된 메모리 위치에 기록하여 주어진 스레드를 정지시키는 작업입니다. 레지스터 상태는 머신마다 다릅니다 (각 머신 유형마다 다른 레지스터 세트가 있기 때문에). 스레드를 미리 설정한 후에는 CPU 레지스터에 다른 스레드의 저장된 스레드를 로드하여 실행을 재개할 수 있다.

운영 체제와 상관없이 스레드 스케줄링의 기본 개념은 동일합니다. 스레드는 CPU (또는 코어 또는 하이퍼 스레드)에서 필요한 기간 동안 실행됩니다. 실행은 CPU 레지스터가 스레드 상태로 채워지고, 결과적으로 CPU가 실행중인 코드 (EIP / RIP 또는 PC)가 해당 스레드 기능의 코드라는 사실을 나타냅니다. 이 실행은 다음 중 하나가 발생할 때까지 계속됩니다.
 -> 스레드가 종료됩니다. 대부분의 스레드는 결국 엔드 포인트에 도달합니다. 스레드 함수가 리턴하거나 스레드가 pthread_exit ()를 호출하여 thread_terminate를 호출합니다.
 
 -> 스레드는 CPU를 포기합니다. 스레드 작업이 수행되지 않더라도 리소스 또는 다른 차단 작업을 기다리는 중이므로이 시점에서 계속 진행하는 것은 의미가 없습니다. 따라서 스레드는 스케줄러가 컨텍스트를 다른 스레드로 전환하도록 기꺼이 요청합니다. 스레드는 또한 기한을 지정하거나 (시계 틱으로) 일부 이벤트에 대한 알림을 요청하여 CPU로 언제 돌아올 것인지 시스템에 알려야합니다.
 
 -> 외부 인터럽트는 스레드 실행을 방해하여 CPU가 스레드 레지스터 상태를 저장하도록 지시하고 인터럽트 처리 코드를 즉시 실행한다. 어쨌든 스레드가 중단되기 때문에 인터럽트 처리 코드에서 돌아오기 전에 시스템은 스케줄러를 호출하여 비 자발적인 컨텍스트 스위치(즉, 선점)가 올바른지 여부를 파악한다. 그러한 자발적이지 않은 컨텍스트 스위치는 스레드의 시간표(Quantum)가 만료된 결과 또는 더 높은 우선순위 스레드가 깨어난 결과물이다.


## Priorities

모든 스레드는 동일하지만 일부 스레드는 다른 스레드보다 더 동일합니다. 다시 말해, 스레드에는 특정 우선 순위가 할당되는데,이 스레드는 예약된 빈도에 직접 영향을 줍니다. 모든 운영 체제는 다양한 우선 순위를 제공합니다. Windows에는 32 개, Linux에는 140 개, Mach에는 128 개가 있습니다.

스케줄러의 osfmk/kern/sched.h 파일은 ASCII 그래픽과 함께 우선 순위 범위(Apple이“우선 순위 밴드”라고 함)의 사용법을 보여줍니다. 커널 스레드의 최소 우선 순위를 사용자 모드보다 높은 80으로 설정하면 다음 실험에서 볼 수있는 매우 특정한 경우를 제외하고 커널 및 시스템 유지 관리가 사용자 모드 스레드를 선점합니다.

### Priorities - Experiment: Viewing Priorities using ps -l

ps의 -l 스위치를 사용하면 실행중인 모든(-e) 프로세스의 우선 순위와 멋진 값이 모두 표시됩니다. 먼저 OS X에서 tr 및 cut을 선택적으로 사용하여 우선 순위, nice value 및 command name을 분리할 수 있습니다.

![11-20](../img/chapter11/11_11_20.PNG)

![11-21](../img/chapter11/11_11_21.PNG)

### Priorities - Priority Shifts

스레드 우선 순위를 지정하는 것이 시작이지만 종종 런타임 중에 이러한 우선 순위를 조정해야합니다. Mach는 스레드의 CPU 사용량 및 전체 시스템로드를 수용하기 위해 각 스레드의 우선 순위를 동적으로 조정합니다. 따라서 스레드는 우선 순위 대역에서“드리프트”되어 CPU를 너무 많이 사용하면 우선 순위가 감소하고 CPU가 충분하지 않으면 우선 순위가 높아집니다. 기존 스케줄러는 osfmk/kern/priority.c 에서 매크로(do_priority_computation)와 함수 (update_priority)를 사용하여 각 스레드의 우선 순위를 동적으로 업데이트합니다. 매크로는 계산 된 sched_usage (함수에 의해 계산되고 CPU 사용량 델타를 고려한)를 pri_shift 값만큼 이동하여 스레드 우선 순위를 토글합니다. pri_shift 값은 글로벌 sched_pri_shift에서 파생되며, 이는 스케줄러에 의해 정기적으로 compute_averages(osfmk / kern / sched_average.c)의 시스템로드 계산의 일부로 업데이트됩니다. CPU 사용량 델타를 빼면 CPU 사용량이 높은 스레드에 효과적으로 불이익을주고 (긍정적 인 사용량 델타가 우선 순위를 떨어 뜨림) CPU 사용량이 적은 스레드에 대해 보상합니다 (음의 사용량 델타가 우선 순위에 추가됨). 스레드의 CPU 사용량이 페널티가 치명적인 지점에 도달하지 않도록하기 위해 update_priority 함수는 점차 CPU 사용량을 노후화합니다. sched_decay_shifts 구조를 사용하여 (11-8)에 표시된 것과 동일한 파일에 정의된 n만큼 CPU 사용량의 지수 감쇄를 시뮬레이션합니다. 사전 계산 된 시프트 값을 사용하여 비트 시프트 및 덧셈으로 표현되는 계산 속도를 높일 수 있으며 곱셈보다 시간이 덜 걸립니다.

![11-22](../img/chapter11/11_11_22.PNG)

Mach는 또한 "throttling"을 지원하며 우선 순위 조절 프로세스, 즉 시스템에 의해 의도적으로 불이익을받는 프로세스에 대해 MAXPRI_THROTTLE를 정의합니다. Mach 호스트 API는 다양한 우선 순위 레벨을보고하는 host_priority_info 구조를 리턴하는 host_info() 함수에 HOST_ PRIORITY_INFO 기능을 제공합니다.

스케줄러가 가능한 한 최소 시간 내에 가장 높은 우선 순위의 다음 실행 가능한 스레드를 찾을 수 있도록 다양하고 일시적인 우선 순위가 있는 모든 스레드를 효율적으로 관리해야합니다. 실행 큐가 그림에 들어가는 곳입니다.

## Run Queues

스레드는 run 큐에 배치되며, 목록 11-6에 표시된 것처럼 osfmk/kern/sched.h에 정의 된 우선 순위 목록입니다.

![11-23](../img/chapter11/11_11_23.PNG)

![11-24](../img/chapter11/11_11_24.PNG)

run 큐는 다중 우선 순위 목록 또는 128 개의 우선 순위 각각에 대해 하나의 큐인 목록의 배열입니다. 실행할 다음 우선 순위를 빠르게 검색하기 위해 Mach는 O(1) 스케줄링이라는 기술을 사용합니다. 즉, 배열을 보지 않고 NULL이 아닌 항목이 발견 될 때까지 각 항목을 검사합니다. 기술적으로 O(1)이지만 실제로는 O(128) 스케줄링입니다. Mach는 비트 맵을 확인하여 32 비트를 동시에 볼 수 있습니다. 이는 스케줄링 로직이 빈번하고 중요한 시간에 실행된다는 점을 고려할 때 조회 속도 O(4)를 가능한 한 빠르고 가장 중요하게 만듭니다.

 run 큐를 정의하면 여러 스케줄러 중 하나를 사용할 때 조건부로 적용됩니다. Mach는 "전통적인"또는 기본 스케줄러를 사용하지만 스케줄러는 모듈 식이며 다른 스케줄러와 함께 수정되거나 대체 될 수 있습니다. 
 
스레드에 새로운 우선 순위를 할당하면 스레드를 한 큐에서 다른 큐로 이동한다는 의미이므로 코드는 스레드의 sched_pri 필드를 직접 수정할 수 없습니다. 이는 set_sched_pri (osfmk / kern / sched_prim.c)에 의해 수행되며, 이는 compute_priority (osfmk / kern / priority.c)에서 호출됩니다. 그림 11-2에 나와 있습니다.

![11-25](../img/chapter11/11_11_25.PNG)

### Run Queues - Wait Queues

스레드는 프로세서를 기다리는 동안 실행 중 상태 또는 준비 상태에 최적입니다. 스레드가 차단되어 일부 IPC 객체 (예 : 뮤텍스 또는 세마포어), 일부 I / O 작업 (예 : 파일 또는 소켓) 또는 이벤트를 기다리는 경우가 있습니다. 이러한 경우 스레드 예약을 고려할 때 이점이 없습니다. 개체 또는 작업이 진행 중이거나 이벤트가 발생한 후에만 실행을 다시 시작할 수 있기 때문입니다.

이러한 경우 스레드가 대기 큐에 배치 될 수 있습니다. 대기 queue_t는 osfmk/kern/kern_types.h에서 불투명 한 지점으로 정의되며, 목록 11-7에 표시된 것처럼 osfmk/kern/wait_queue.c에서 구현됩니다.

![11-26](../img/chapter11/11_11_26.PNG)

대기 큐 처리 기능은 osfmk/kern/wait_queue.h의 커널 구성 요소에서 사용하기 위해 내보내집니다. 대기 대기열에 스레드를 추가하기 위해 wait_queue_assert_wait [64 [_ locked]] 변형을 사용할 수 있습니다. 스레드가 실시간, 특권 또는 FIFO 대기 큐에있는 경우를 제외하고 함수는 모두 큐의 끝에 스레드를 큐에 넣습니다 (이 경우 큐의 헤드에 큐에 대기). 이 함수는 assert_wait (osfmk/kern/sched_prim.c) 및 기타 래퍼 (커널 전체, 특히 BSD 계층)에 의해 추가로 래핑됩니다.

대기 조건이 충족되면 대기 스레드를 차단 해제하고 다시 발송할 수 있습니다. wait_queue_wakeup64_ [all | one] _locked (이벤트가 발생할 때 하나 또는 모든 스레드를 깨우기 위해)가 이 목적으로 사용됩니다. 이 함수는 wait 큐에서 스레드를 대기열에서 빼고 thread_go를 사용하여 스레드를 디스패치합니다. thread_go는 스레드를 차단하고 (thread_unblock을 사용하여) 스레드를 디스패치합니다 (thread_setrun 사용).


### Run Queues - CPU Affinity

멀티 코어, SMP 또는 하이퍼 스레딩을 사용하는 최신 아키텍처에서는 특정 스레드를 하나 이상의 특정 CPU에 연결할 수도 있습니다. 이는 스레드가 동일한 CPU에서 실행되고 반환 할 때 스레드가 데이터를 CPU 캐시에 "남겨두어" 스레드와 시스템 모두에 유용 할 수 있습니다.

Mach의 용어에서 스레드의 CPU 속성은 바인딩으로 정의됩니다. thread_bind(osfmk/kern/sched_prim.c)는 이러한 목적으로 사용되며 thread_t의 bound_processor 필드만 업데이트합니다. 필드가 PROCESSOR_NULL 이외의 값으로 설정된 경우 스레드와 관련된 향후 예약 결정(예 : thread_setrun)은 스레드를 해당 프로세서의 실행 큐로만 전달합니다.

## MACH SCHEDULER SPECIFICS

지금까지 제시된 스케줄링에 대한 관점은 실제로 모든 최신 운영 체제에 공통입니다. 그러나 마하에는 주목할만한 몇 가지 기능이 추가되었습니다
 
> HandOff를 통해 스레드가 자발적으로 CPU를 생성 할 수 있지만 다른 스레드는 아닙니다. 오히려 CPU가 특정 스레드 (선택한 스레드)로 전달합니다. 이 기능은 메시지 전달 커널이고 메시지가 스레드간에 전달된다는 점을 고려하면 마하에서 특히 유용합니다. 이렇게하면 다음에 메시지 처리 스레드, 발신자 또는 수신자가 예약 될 때를 기다리지 않고 대기 시간을 최소화하면서 메시지를 처리 할 수 있습니다.

> Continuations(연속)은 스레드가 자체 스택을 별로 신경 쓰지 않고 폐기 할 수 있는 경우에 사용되며 스택을 복원하지 않고 시스템을 다시 시작할 수 있습니다. 이 주요 기능은 Mach에 특화되어 있으며 커널 주변의 여러 곳에서 사용됩니다.

> AST (Asynchronous Software Traps)는 저수준 하드웨어 트랩 메커니즘을 보완하는 소프트웨어입니다. 커널은 AST를 사용하여 이벤트 스케줄링과 같이주의가 필요한 대역 외 이벤트에 응답 할 수 있습니다.

> 스케줄링 알고리즘은 모듈식이며 스케줄러는 부팅시 동적으로 설정할 수 있습니다 (sched boot-arg 사용). 그러나 실제로는 하나의 스케줄러 (소위 전통적인 스케줄러)만 사용됩니다.


### MACH SCHEDULER SPECIFICS - Handoffs

모든 운영 체제는 yielding 개념을 지원합니다. 이는 CPU를 다른 스레드에 자발적으로 포기하는 행위입니다. 고전적인 형태의 yielding은 yielding 스레드가 후속 작업을 선택할 수 없도록하며 선택 사항은 스케줄러에 맡겨집니다.

Mach는 CPU를 전달하는 옵션을 추가하여 이를 개선합니다. 이를 통해 yielding 스레드는 스케줄러에 다음으로 실행할 최상의 스레드에 대한 힌트를 제공 할 수 있습니다. 이것은 스케줄러를 완전히 준수하지는 않습니다. 스케줄러는 다른 스레드로 제어를 전송하도록 선택할 수 있습니다 (지정된 스레드가 실행 불가능한 경우). 그러나 스케줄러는 스레드 정책을 무시하므로 일반적으로 핸드 오프가 성공합니다. 핸드 오프의 결과로 현재 스레드의 남은 quantum가 예약 될 새 스레드에 제공됩니다.

yielding보다는 핸드 오프하기 위해 스레드는 전환 할 스레드의 포트를 지정하는 thread_switch ()를 호출하고 선택적 플래그 (예 : 교체 스레드의 우선 순위를 낮춤)와 이러한 옵션이 적용되는 시간을 지정합니다. 더 흥미로운 점은 사용자 모드에서 스레드 핸드 오프 메커니즘에 액세스 할 수 있다는 것입니다. Mach는 thread_switch ()를 트랩 으로 내 보내서 사용자 모드에서 호출 할 수 있습니다. 이것은 실제로 매뉴얼 페이지 (osfmk/man/thread_switch.html)가 있는 몇 가지 마하 트랩 중 하나입니다.

### MACH SCHEDULER SPECIFICS - Continuations

컨텍스트 전환은 대부분의 운영 체제에서 간단하지만 각 스레드에 고유 한 작업이있는 클래식 모델에 따라 Mach는 continuation개념을 도입하여 대안을 제공합니다. continuation은 선택적 재개 함수 (매개 변수와 함께)이며 스레드가 자발적으로 컨텍스트 전환을 요청하는지 여부를 지정할 수 있습니다.

continuation이 지정되면 스레드가 재개 될 때 새 스택이 있는 continuation 지점에서 다시 로드되고 이전 상태는 저장되지 않습니다. 레지스터의 저장 및 로드를 생략 할 수 있기 때문에 컨텍스트 전환이 훨씬 빨라집니다 (또한 커널 스택의 공간을 상당히 절약 할 수 있으며, 이는 매우 작고 4 페이지 또는 16K에 불과합니다).

continuations상태의 스레드는 스레드 상태에 4 ~ 5KB 만 필요하므로 다른 16K를 절약 할 수 있습니다. 전체 레지스터 상태 및 스레드 스택 대신 연속 및 선택적 매개 변수만 저장하면되며 스레드 구조 자체에서 수행 할 수 있습니다.

continuation에 대한 간단한 테스트가 수행 될 수 있으며, 발견된 경우 매개 변수가 전달된 상태로 간단히 점프합니다.
스레드는 thread_block ()을 사용하여 차단할 욕구를 지정하고 선택적으로 연속을 지정합니다 (또는 표준 모드를 ​​선호하는 경우 THREAD_CONTINUE_NULL을 사용).

continuation에 대한 매개 변수는 thread_block_parameter()에 의해 지정 될 수 있습니다. 두 호출 모두 thread_block_reason ()에 대한 래퍼입니다.이 장의 뒷부분에 나오는 "명시 적 선점"섹션에서 설명합니다.

continuation은 컨텍스트 전환 비용을 완화하기 위한 빠르고 효율적인 메커니즘이며 주로 마하의 커널 스레드에서 사용됩니다. 실제로, Mach의 kernel_thread_create (및 주요 호출자 인 kernel_thread_start_priority)는 Listing 11-8에 표시된 것처럼 연속 개념을 기반으로 구축되었습니다.

![11-27](../img/chapter11/11_11_27.PNG)

![11-28](../img/chapter11/11_11_28.PNG)

continuation은 커널 스레드에서 특히 매력적입니다. continuation을 설정하는 것은 단순히 스레드 진입 점이므로 간단합니다. 따라서 마하 커널 스레드가 시작되는 방식입니다. 사용자 모드 스레드 작성은 또한 thread_create_ internal2에서 연속을 thread_bootstrap_return()으로 설정하여 continuation을 사용합니다. 이것은 단지 DTrace 후크이며, thread_exception_return()이 뒤 따르며, 이는 사용자 모드로 돌아갑니다.

계속하려면 설정 스레드가 선점 및 연속 논리를 모두 인식해야합니다. 따라서 Mach는 명시적 및 암시적이라는 두 가지 서로 다른 선점 모델을 지원하고 명시적 선점에만 사용할 수있는 continuation 모델을 지원합니다. 이것들은 다음에 논의됩니다. 계속은 Mach의 최초 개발자 중 한 명인 Richard Draves의 발명품입니다 (이 이름은osfmk / ipc 등의 XNU 소스를 여전히 장식합니다).

### MACH SCHEDULER SPECIFICS - Preemption Modes

시스템의 스레드는 다음 두 가지 방법 중 하나로 선점 될 수 있습니다. 명시적으로 스레드가 CPU 제어를 포기하거나 차단으로 정의된 작업에 들어갔을 때 인터럽트로 인해 암시적으로 발생합니다. 명시적 선점은 사전에 예측 가능하기 때문에 동기식이라고도합니다. 본질적으로 예측할 수 없는 인터럽트는 암시적인 선점을 비동기 적으로 만듭니다.

### MACH SCHEDULER SPECIFICS - Preemption Modes - Explicit Preemption
스레드가 자발적으로 CPU를 포기하려고 할 때 명시적 선점이 발생합니다. 리소스 또는 I/O를 기다리거나 일정 시간 동안 절전 모드로 인해 발생할 수 있습니다. 사용자 모드 스레드는 read(), select(), sleep 등과 같은 차단 시스템 호출을 호출 할 때 명시적 선점을 따릅니다.

명시적 선점을 제공하기 위해 Mach는 thread_block_reason() 함수를 제공합니다. osfmk/kern/sched_prim.c에 정의된 함수는 continuation 함수, 매개 변수 및 reason의 세 가지 매개 변수를 사용합니다. 그 이유는 나중에 논의 할 AST_ (비동기 소프트웨어 트랩) 상수입니다.

![11-29](../img/chapter11/11_11_29.PNG)

![11-30](../img/chapter11/11_11_30.PNG)

thread_block_parameter() 및 thread_block()이라는 두 가지 도우미 함수도 정의되어 있습니다. 전자는 reason 매개 변수를 AST_NONE으로 설정하여 thread_block_reason()을 호출하고 후자는 동일하게 수행하지만 매개 변수를 NULL로 설정합니다.

thread_block을 호출하면 연속을 설정할 수 있으며, 이는 매개 변수 (current_thread ()-> parameter)와 함께 thread_t 구조(current_thread ()-> continuation)에 저장됩니다. 그런 다음 thread_block() 함수는 thread_select()를 호출하여 현재 프로세서의 다음 스레드 (현재와 다를 수도 있고 다를 수도 있음)를 가져 와서 thread_invoke()를 호출하려고 시도합니다.

thread_invoke() 함수는 컨텍스트 전환을 수행하고 continuation을 처리합니다. 이 함수는 상당히 길며, 기본적으로 호출할 새 스레드에 continuation 함수가 있는지 확인합니다. 만약 있다면 continuation 함수가 직접 호출됩니다. 그렇지 않으면 전체 컨텍스트 전환을 수행해야합니다.

높은 수준의 관점에서 그림 11-3과 같이 작업이 실제로 매우 간단합니다.

![11-31](../img/chapter11/11_11_31.PNG)

call_continuation()은 상태를 복원하는 훨씬 빠른 기계 의존적 메커니즘입니다. 코드 11-10은 x86_64에서 어떻게 효율적인 코드로 구현 될 수 있는지 보여줍니다.

![11-32](../img/chapter11/11_11_32.PNG)

### MACH SCHEDULER SPECIFICS - Preemption Modes - Implicit Preemption

Mac OS 9는 명시적 선점 개념을 중심으로 구축 되었기 때문에 협력적인 멀티 태스킹 시스템이되었습니다. 그러나 실행 중인 스레드에 CPU를 양도하는 선택을 그대로 두는 것은 극히 신뢰할 수 없기 때문에 명시적인 선점은 본질적으로 제한적입니다. 스레드는 시간이 많이 걸리는 처리 또는 끝없는 루프에서 포착 될 수 있으며 명시적인 선점에 도달 할 수 없습니다.

반대로 Mac OS X은 선점형 멀티 태스킹 시스템입니다. 일반적으로, Mach는 스레드 준비 여부에 관계없이 특정 시점에 스레드를 선점할 권리를 보유합니다.

명시적 선점과 달리 암시적 선점은 스레드에 표시되지 않습니다. 스레드는 좋지 못하고 상태는 투명하게 저장 및 복원됩니다. 대부분의 스레드는 어쨌든 I/O 바인딩 될 가능성이 있으므로 이에 대해 신경 쓰지 않습니다. 그러나 CPU를 많이 사용하는 스레드의 경우 특히 시간이 중요한 성능 (예 : 비디오 및 오디오 디코딩)이 필요할 때 문제가 될 수 있습니다.

암시적 선점은 개념상 명시적 대응보다 훨씬 간단합니다. 계속되지 않기 때문입니다. 스레드가 일시 중단 된 것을 인식하지 못하므로 연속을 요청할 수 없습니다.

스레드는 자체 스케줄링을 명시적으로 제어 할 수 없지만 Mach는 서비스 클래스를 보장하기 위해 작동 할 수 있는 몇 가지 사전 설정된 정책을 제공합니다. Mach는 실시간 공유 시스템이 아니라 시분할 시스템이므로 서비스를 보장 할 수는 없기 때문에 “work toward”를 참고하십시오. 사용자 모드에서 볼 수 있는 마하 트랩인 thread_ policy_set ()을 사용하면 이러한 정책을 요청할 수 있습니다. 이 기능은 다음과 같이 osfmk/kern/thread_policy.c에 정의되어 있습니다.

![11-33](../img/chapter11/11_11_33.PNG)

이 함수는 인수 (즉, 스레드가 THREAD_NULL이 아니고 스레드-> static_param이 false 임)를 확인한 후 thread 인수를 flavor 인수에 대해 switch()를 호출하는 thread_policy_set_internal()을  호출합니다. 표 11-6 항목 중 하나 일 수 있습니다.

![11-34](../img/chapter11/11_11_34.PNG)

이러한 특성을 통해 개별 스레드의 일정을 세밀하게 제어 할 수 있습니다. 기본 정책 THREAD_STANDARD_POLICY는 공정한 시간 공유에 사용됩니다. 추가 매개 변수가 필요하지 않습니다. THREAD_EXTENDED_POLICY는 이를 기반으로하며 false인 경우 대체 정책을 지정하고 true인 경우 표준 정책으로 돌아가는 부울 매개 변수 timeshare를 추가합니다.

보다 복잡하고 실시간 정책에 더 가까운 THREAD_TIME_CONSTRAINT_POLICY는 세밀한 스케줄링 조정을 허용합니다. 이 정책의 핵심은 해당 스레드의 스케줄링인 "프로세스 도착"개념입니다. 단위는 커널의 CPU 클럭 주기로 측정됩니다. 이 정책은 여러 매개 변수를 기반으로합니다.
> Period: 두 개의 연속된 프로세싱이 도착하는 사이의 시간을 요청합니다. 이 값이 0이 아니면, 해당 스레드는 주기마다 한 번씩 프로세서 시간을 찾는 것으로 가정합니다.
> Computation: 스레드가 예약 될 때마다 필요한 계산 시간을 지정하는 32 비트 정수입니다.
> Constraint: 계산 시작과 끝 사이의 최대 (실시간)시간입니다.
> Preemptible: 계산이 중단 될 수 있는지 여부를 지정하는 부울 값. 즉, 이러한 계산주기가 연속적이어야하는지 (preemptible = false) 아닌지 (preemptible = true)

THREAD_PRECEDENCE_POLICY는 한 개의 매개 변수인 importance을 취하는데, 이 매개 변수는 동일한 Task의 다른 스레드와 비교하여 이 스레드의 상대적 중요성을 제공합니다. 스레드에 대해 스레드가 증가하거나 감소 할 수 있음을 의미하는 값은 부호가 있지만 XNU의 최소 우선 순위는 IDLE_PRI이며 0으로 정의됩니다.

THREAD_AFFINITY_POLICY는 동일한 캐시의 스레드간에 L2 캐시 선호도를 제공합니다. 즉, 이러한 스레드는 코어에 관계없이 동일한 CPU에서 실행될 수 있지만 (모든 코어가 동일한 L2 캐시를 공유하므로) 실제 SMP 환경에서 CPU를 교차하지는 않습니다. 이 선호도를 제공하기 위해 정책은 관련 프로세스 (즉, 상위 및 하위)간에 공유되는 affinity_tag를 사용합니다. 

THREAD_BACKGROUND_POLICY는 백그라운드 스레드에 사용됩니다. 즉, 시스템에서 우선 순위가 낮고 중요도가 높은 스레드입니다. 이것은 OS X에서 정의된 것이 아니라 iOS에서 사용되며 SpringBoard에 의해 백그라운드로 전송되는 Apps에 대한 사용을 제안합니다.

Task는 "role"필드를 제공하여 일정 수준의 일정을 조정합니다.이 작업은 표 11-7에 표시된 다음 중 하나 일 수 있습니다.

![11-35](../img/chapter11/11_11_35.PNG)

![11-36](../img/chapter11/11_11_36.PNG)

따라서 Task "role"은 스레드 예약에 영향을 줍니다.

암시적 선점을 허용하려면 커널 수준에서 비동기 이벤트 및 중단을 지원하는 일부 메커니즘이 있어야합니다. 이 메커니즘은 마하의 AST (Asynchronous Software Traps)이며 다음에 설명합니다. 

## Asynchronous Software Traps (ASTs)

AST는 기술적인 비하드웨어 트랩 상태입니다. AST는 커널 작업에 중요하며 이 장의 앞부분에서 설명한 선점 이벤트와 같은 스케줄링 이벤트 및 13 장에서 논의 된 BSD 신호가 구현되는 인쇄물 역할을합니다.

AST는 스레드의 제어 블록에서 다양한 비트의 필드로 구현되며 thread_ast_set()에 대한 호출로 개별적으로 설정할 수 있습니다. Listing 11-11과 같이 매크로이다.

![11-37](../img/chapter11/11_11_37.PNG)

Mach에서 정의된 "reason"은 osfmk/kern/ast.h에 있지만 실제로 문서화가 잘되어 있지 않습니다. 표 11-8은 정의 된 AST와 그 목적을 보여줍니다.

![11-38](../img/chapter11/11_11_38.PNG)

AST는 콤보에서도 사용될 수 있으며, 이는 이전 플래그의 비트 단위 OR입니다. 이것들은 표 11-9에 나와 있습니다.

![11-39](../img/chapter11/11_11_39.PNG)

콤보는 AST를 두 가지 클래스로 분류하는데 사용됩니다: 선점 관련 클래스와 스케줄러에서 설정 또는 설정 해제 할 수 있는 클래스

시스템이 트랩(user_trap_return 호출 후) 또는 인터럽트(INTERRUPT 호출 후)에서 복귀하면 즉시 사용자 모드로 돌아 가지 않습니다. 대신 코드는 스레드의 필드를 보고 AST가 있는지 확인합니다. 0이 아닌 경우 목록 11-12에 표시된 것처럼 i386_astintr()을 호출하여 처리합니다.

![11-40](../img/chapter11/11_11_40.PNG)

그림 11-4는 목록 11-12와 같이 트랩 및 인터럽트에서 복귀 할 때의 AST 검사 점을 보여줍니다. 따라서 AST는 모든 인터럽트가 활성화 된 상태로 실행되지만 여전히 "프로세스 시간을 벗어난" 상태에서 실행된다는 점에서 Linux의 softIRQ와 약간 비슷합니다.

![11-41](../img/chapter11/11_11_41.PNG)

![11-42](../img/chapter11/11_11_42.PNG)

커널 트랩 및 커널 스레드 종료시 호출 될 수 있는 ast_taken 함수는 모든 스레드에서 AST를 처리하여 커널 유휴 스레드를 저장합니다. AST_URGENT 및 AST_PREEMPT (AST_PREEMPTION 콤보)로 표시된 AST는 스레드를 즉시 선점합니다. 그렇지 않으면 이 함수는 AST 이벤트(신호와 같은)를 Mach에 넣었지만 임시적으로 해킹 한 AST_BSD를 확인합니다. BSD AST가 설정되면 신호를 처리하기 위해 bsd_ast(bsd/kern/kern_sig.c에서)가 호출됩니다. 

AST의 특별한 경우는 Preemption Free Zone(PFZ)으로 알려진 통신 영역의 특수 영역에서 기능이 실행될 때입니다. 이 영역에서는 뛰어난 AST가 지연됩니다. 주소가 PFZ에있는 것으로 확인되면 AST는 PFZ가 종료 될 때까지 보류 중으로 표시됩니다. PFZ 나 commpage는 잘 문서화되어 있지 않지만 제공되는 내용은 목록 11-14에 나와 있습니다.

![11-43](../img/chapter11/11_11_43.PNG)

## Scheduling Algorithms

마하의 스레드 스케줄링은 확장성이 뛰어나며 실제로 스레드 스케줄링에 사용되는 알고리즘을 변경할 수 있습니다. 표 11-10은 osfmk/kern/sched_prim.h를 보면 무엇을 보게되는지 보여줍니다.

![11-44](../img/chapter11/11_11_44.PNG)

일반적으로 기존 스케줄러는 하나의 스케줄러만 사용 가능하지만 마하 아키텍처에서는 컴파일 중에 해당 CONFIG_SCHED_ 지시문을 사용하여 추가 스케줄러를 정의하고 선택할 수 있습니다. 사용되는 스케줄러는 스케줄러 boot-arg 또는 장치 트리 항목으로 지정할 수 있습니다.

각 스케줄러 객체는 sched_dispatch_table 구조를 유지하며, 여기서 다양한 연산(생각 : 메소드)은 함수 포인터로 유지됩니다. 글로벌 테이블 sched_current_dispatch는 현재 활성 스케줄링 알고리즘을 보유하며 런타임 중에 스케줄러 전환을 허용합니다. 모든 스케줄러는 동일한 필드를 구현해야하며, 일반 스케줄러 로직은 SCHED 매크로를 사용하여 호출합니다 (목록 11-15 참조).

![11-45](../img/chapter11/11_11_45.PNG)

![11-46](../img/chapter11/11_11_46.PNG)

![11-47](../img/chapter11/11_11_47.PNG)

![11-48](../img/chapter11/11_11_48.PNG)

스레드 스케줄링을 계속 유지하기 위해 모든 스케줄은 maintenance_continuation 기능을 구현합니다. 이것은 커널 스레드에 대해이 장의 앞부분에서 설명한 연속 메커니즘을 적용한 것입니다. 여기에서 스케줄러 스레드는 clock_deadline_ for_periodic_event를 사용하여 시계 알림을 등록합니다. assert_wait_deadline을 호출하면 스레드가 지정된 최종 기한 내에 실행되고 스레드가 계속 차단됩니다. 프로세스는 스케줄러의 초기화 기능에서 시작됩니다.

스케줄러는이 장에서 논의 된 AST (Asynchronous Software Trap) 메커니즘을 많이 사용합니다. 구체적으로, 스케줄러는 매우 특정한 유형의 트랩을 사용합니다 : AST_ PREEMPTION. 이들은 스케줄링 로직을 묶어 처리 및 커널 / 사용자 공간 전환을 중단시킵니다. 스케줄링 로직이 kdebug 메커니즘 (5 장에서 설명)에 대한 호출과 연계되어 있다는 점도 주목할 가치가 있습니다. kdebug 코드 (DBG_MACH_SCHED로 정의되고 bsd /sys/kdebug.h에 선언)는 스케줄러 흐름에서 가장 중요한 점을 표시합니다.

## TIMER INTERRUPTS

이 장은 지금까지 스케줄링 로직에서 마하가 사용하는 기본 요소와 구성을 다루었다. 이 섹션에서는 이러한 아이디어가 스케줄링, 즉 타이머 인터럽트를 유발하는 "엔진"과 통합됩니다.

## Interrupt-Driven Scheduling

시스템이 선점형 멀티 태스킹을 제공하려면 먼저 스케줄러가 CPU를 제어하여 현재 실행중인 스레드를 선점한 다음 스케줄링 알고리즘을 수행하여 현재 스레드가 실행을 재개 할 수 있는지 여부를 결정하는 몇 가지 메커니즘을 지원해야합니다. 또는 CPU를보다 중요한 스레드로 양도하려면 “kicked-out” 해야합니다.

기존 스레드에서 CPU를 제어하기 위해 최신 운영 체제(Apple 포함)는 이미 존재하는 하드웨어 인터럽트 메커니즘을 활용합니다. 인터럽트의 특성으로 인해 CPU가 인터럽트에서 "모든 항목을 삭제"하고 인터럽트 처리기(인터럽트 서비스 루틴 또는 ISR이라고도 함)에 longjmp를 강제로 삭제하기 때문에 인터럽트에서 스케줄러를 실행하기 위해 인터럽트 메커니즘에 의존하는 것이 합리적입니다. 

그러나 한 가지 작은 문제가 남아 있습니다. 인터럽트는 비동기적이므로 언제든지 발생할 수 있으며 예측할 수 없습니다. 사용량이 많은 시스템이 초당 수천 개의 인터럽트를 처리하는 동안 quiet period I/O 시스템의 일반적인 인터럽트 소스(디스크, 네트워크 및 사용자)는 모두 유휴 상태이며 인터럽트 방식으로 유휴 상태 일 수도 있습니다.

다행히도 이러한 인터럽트 소스가 존재하며 XNU는 이를 실시간 clock 또는 rtclock이라고합니다. 이 clock은 하드웨어에 따라 다릅니다 (Intel 아키텍처는 이러한 목적으로 로컬 CPU의 APIC를 사용함). 주어진 사이클 수 후 인터럽트를 생성하기 위해 커널에 의해 구성 될 수 있습니다. 인터럽트 소스는 종종 타이머 인터럽트라고합니다. 이전 버전의 XNU는 타이머 인터럽트를 초당 고정 횟수 (hz)로 트리거했습니다. 이 값은 커널의 BSD 부분 인 bsd/kern /clock.c에 전체적으로 정의되어 있으며 (목록 11-16에 표시됨)

![11-49](../img/chapter11/11_11_49.PNG)

실제로 이것을 경멸해야 할 충분한 이유가 있습니다. 고정된 간격으로 커널을 중단시키는 타이머는 예측 가능하지만 불필요한 인터럽트를 발생시킵니다. hz 값이 너무 높으면 불필요한 인터럽트가 너무 많다는 의미입니다. 반면에, 값이 너무 낮 으면 서브 hz 지연이 타이트한 루프에 의해서만 달성 될 수 있으므로 시스템의 응답성이 떨어집니다. 이전 버전의 OS X에서 사용된 이전 hertz_tick() 함수는 여전히 존재하지만 XNU가 프로파일링으로 컴파일된 경우에만 사용되지 않고 조건부로 컴파일됩니다.

해결책은 tick-less 커널의 다른 모델을 채택하는 것입니다. 이 모델은 Linux와 매우 유사합니다. 모든 타이머 인터럽트에서 스케줄러가 필요하다고 생각할 때만 다음 인터럽트를 예약하도록 타이머가 재설정됩니다. 

즉, 모든 타이머 인터럽트에서 인터럽트 핸들러는 보류중인 마감 시간 목록을 (매우 빠르게) 전달해야합니다. 이는(마감 시간 목록) 주로 스레드에 의해 설정된 sleep 시간을 초과하며, 필요한 경우 조치를 취하고 그에 따라 다음 타이머 인터럽트를 예약합니다. 각 타이머 인터럽트에서 더 많은 처리를 수행하면 허위 인터럽트를 절약 할 가치가 있으며 가장 긴급한 마감 기한만 추적하여 처리를 최소화 할 수 있습니다.

## Timer Interrupt Processing in XNU

XNU는 CPU별로 타이머 기반 이벤트를 추적하는데 사용되는 rtclock_timer_t 유형(osfmk/i386/cpu_data.h)을 정의합니다. 이 구조는 타이머의 deadline과 call_entry 구조(osfmk/kern/call_entry.h)의 queue를 기록하며 목록 11-17에 정의된 callout을 유지합니다.

![11-50](../img/chapter11/11_11_50.PNG)

rtclock_timer의 queue는 deadline의 오름차순으로 정렬되어 있으며 deadline 필드는 가장 가까운 deadline(예 : 대기열의 헤드 항목)으로 설정됩니다.

XNU는 기계에 독립적인 이벤트 타이머 개념 (Etimer라고도 함)을 사용하여 rtclock_timer를 랩핑하고 실제 머신 레벨 타이머 인터럽트 구현을 숨깁니다.

### Timer Interrupt Processing in XNU - Scheduling Deadlines

deadline 시간 타이머는 timer_queue_assign (osfmk/i386/etimer.c)을 통해 설정됩니다 (읽기 : rtclock 대기열에 추가됨). 이 함수는 현재 CPU의 rtclock_timer.deadline에 이미 설정된 것보다 빠른 (읽기 : 빨리 만료) 경우에만 기한을 설정합니다.

하드웨어 레벨에서의 최종 기한 설정은 etimer_set_deadline에 의해 처리되고 그 뒤에 CPU의 로컬 APIC를 설정하는 etimer_resync_deadlines (osfmk / i386 / etimer.c)에 대한 호출이 처리됩니다.

스케줄러는 스레드의 wait_timer에서 osfmk/kern/timer_call.c의 timer_call_enter를 사용하여 타이머 callout의 상위 레벨 추상화를 통해 timer_queue_assign과 인터페이스합니다. callout은 목록 11-18에 표시된 것처럼 osfmk/kern/timer_ call_entry.h에 미리 설정된 인수가있는 함수 포인터입니다.

![11-51](../img/chapter11/11_11_51.PNG)

중요하지 않은 것으로 간주되는 타이머 이벤트에는 소위 "슬로프"값이 추가되어 동시에 만료될 확률을 높이기 위해 이들을 통합하고 (전체 타이머 인터럽트를 줄이게 됩니다).timer_call_enter의 다양한 호출자는 TIMER_CALL_CRITICAL 플래그를 지정하여 중요한 호출로 선언 할 수 있습니다.

스케줄러 끝에서 타이머 deadline을 설정하는 프로세스는 그림 11-5에 나와 있습니다.

### Timer Interrupt Processing in XNU - Timer Interrupt Handling

타이머 인터럽트 처리는 rtclock_intr(osfmk/i386/rtclock.c)에 의해 수행됩니다. 이 기능 자체는 그다지 중요하지 않습니다. 단지 모든 인터럽트가 비활성화되어 어떤 모드 (커널 또는 사용자)가 중단되었는지를 결정하고 기존 스레드의 레지스터를 저장합니다. 실제 작업은 etimer_intr (osfmk/i386/etimer.c)에 대한 호출로 이루어지며, 타이머 deadlineㄴ(rtclock_timer-> 마감일) 또는 전원 관리 deadline(osfmk/i386/pmCPU.c의 pmCPUGetDeadline ()에서 리턴 된대로)이 만료되었는지 여부를 확인합니다. 스케줄러를 deadline 큐의 생산자로 생각할 수 있으며 이 기능은 해당 소비자입니다.

![11-52](../img/chapter11/11_11_52.PNG)

타이머에 대해 동작하기 위해 etimer_intr은 timer_queue_expire (또는 전원 관리 관련 마감일의 경우 pmCPUDeadline)를 호출합니다. 이 타이머는 queue를 걷고 두 개의 인수와 함께 만료 된 타이머의 콜 아웃 기능을 호출합니다(또한 호출 전후에 kdebug 이벤트를 기록합니다). 이 함수는 deadline이 아직 만료되지 않은 첫 번째 콜아웃에 도달 할 때까지 콜아웃을 큐에서 호출합니다. queue는 deadline을 늘리는 순서대로 정렬되므로 다른 모든 deadline도 보류됩니다. 만료되지 않은 첫 번째 deadline은 실제로 다음 처리 deadline이되므로 etimer_intr로 반환됩니다. 그림 11-6에 나와 있습니다.

![11-53](../img/chapter11/11_11_53.PNG)

### Timer Interrupt Processing in XNU - Setting the Hardware Pop

deadline 시간 타이머는 하드웨어 수준과 통신해야하며 하드웨어가 만료 될 때 다음 타이머 인터럽트를 생성하도록 하드웨어에 요청해야 합니다. 이것이 두 경우 모두 (즉, 타이머 이벤트 스케줄링 및 타이머 만료에 대한 행동) etimer_resync_deadlines()에 대한 호출을 포함하는 이유입니다.

이 기능은 타이머 또는 전원 관리 기한이 보류 중인지 여부를 확인합니다 (만료 된 후 일정이 변경 될 수 있음). 두 가지 유형의 deadline을 찾으면, 함수는 setPop() (osfmk/i386/rtclock.c)을 호출하여 두 가지 중 더 이른 시점으로 다음 인터럽트를 스케줄합니다. deadline이 없으면 EndOfAllTime을 나타내는 값으로 setPop()이 호출됩니다. setPop()은 rtc_timer 전역을 사용하여 CPU의 로컬 APIC에 타이머를 설정합니다.
그림 11-7은 etimer_resync_deadlines의 흐름을 보여줍니다.

![11-54](../img/chapter11/11_11_54.PNG)

## EXCEPTIONS

9장에서 프로세서 트랩과 예외에 대한 저수준 토론을 기억하자면, 커널의 책임 중 하나는 이러한 이벤트를 처리하는 것이며, 모든 현대 커널은 비슷합니다. 다른 점은 이 기능을 달성하기 위해 각 커널이 취할 수있는 특정 접근 방식입니다.

Mach는 기존 메시지 전달 아키텍처에서 구현된 예외에 대해 고유한 접근 방식을 취합니다. 섹션에 제시된 모델은 경량 아키텍처이며 실제로 예외를 처리(즉, 처리 및 수정 가능)하지 않습니다. 이것은 13 장에서 볼 수 있듯이 상위 계층인 BSD입니다.

## The Mach Exception Model

Mach 예외 처리의 설계자들은 다음과 같은 것들을 언급한다. 

> Single facility with consistent semantics: Mach는 사용자 정의, 플랫폼 독립적 또는 플랫폼 별 여부에 관계없이 모든 예외에 대해 하나의 예외 처리 메커니즘만 제공합니다. 예외는 예외 유형으로 그룹화되며 특정 플랫폼은 특정 하위 유형을 정의 할 수 있습니다.

> Cleanliness and simplicity: 인터페이스는 매우 우아하고 (효율적이지 않은 경우) 이미 정의 된 메시지와 포트 아키텍처에 의존합니다. 이를 통해 디버거 및 외부 처리기 및 이론적으로 네트워크 수준 예외 처리에 대한 확장성이 가능합니다.

Mach에서 예외는 커널의 주요 기능인 메시지 전달을 통해 처리됩니다. 예외는 오류 스레드 또는 Task에 의해 발생하고 (msg_send()로) 처리기에 의해 잡히며(msg_recv()로) 메시지 이상입니다. 그런 다음 핸들러는 예외를 처리하고 예외를 지우거나 (즉, 예외를 처리 된 것으로 표시 한 후 계속) 스레드 종료를 결정할 수 있습니다.
 
예외 처리기가 오류 스레드의 컨텍스트에서 실행되는 다른 모델과 달리 Mach는 오류 스레드가 미리 지정된 예외 포트에 메시지를 보내고 응답을 기다리도록하여 별도의 컨텍스트에서 예외 처리기를 실행합니다. 각 작업은 예외 포트를 등록 할 수 있으며 이 예외 포트는 동일한 작업의 모든 스레드에 영향을 줍니다. 또한 개별 스레드는 thread_set_exception_ports를 사용하여 자체 예외 포트를 등록 할 수 있습니다. 일반적으로 Task 및 스레드 예외 포트는 모두 NULL이므로 예외가 처리되지 않습니다. 일단 생성되면이 포트는 시스템의 다른 포트와 동일하며 다른 작업이나 다른 호스트로 전달 될 수 있습니다.

예외가 발생하면 먼저 예외를 스레드 예외 포트로, 그런 다음 Task 예외 포트로, 마지막으로 호스트 (예 : 시스템 수준 등록 기본값) 예외 포트로 올리려고 합니다. 이 중 어느 것도 KERN_SUCCESS가되지 않으면 전체 작업이 종료됩니다. 그러나 언급했듯이 Mach는 예외 처리 논리를 제공하지 않으며 예외 알림을 전달하는 프레임워크만 제공합니다.

## Implementation Details

예외는 일반적으로 프로세서 트랩으로 수명을 시작합니다. 트랩을 처리하기 위해 모든 최신 커널은 트랩 처리기를 설치합니다. 이들은 8 장에서 설명한 것처럼 커널의 어셈블리 언어 코어에 의해 설치되고 기본 프로세서 아키텍처와 일치하는 low-level 기능입니다.

Mach는 하드웨어 추상화 계층을 유지하지 않지만 기계 고유의 부분과 기계에 구애받지 않는 부분 사이에 가능한 한 깨끗하게 절단하는 것을 목표로 합니다. 예외 코드는 특정 아키텍처와 관련된 별도의 파일에 포함되며 XNU 컴파일에 수동으로 포함됩니다. 아키텍처 독립적 예외 코드는 <mach/exception_types.h>에 정의되어 있습니다. 이 코드는 모든 플랫폼에 공통이며 <mach/machine/exception.h>의 #include는 기계 별 서브 코드를 지원합니다. XNU 오픈 소스에서이 파일은 i386/x86_64의 일반적인 <mach/i386/exception.h>에 대한 #include를 포함하는 스텁(stub)이며 다른 모든 플랫폼에 대한 컴파일에 실패합니다 (#error 아키텍처는 지원되지 않음). 그러나 iOS의 경우 Apple은 <mach/arm/exception.h>를 정의하며, 이는 iPhone SDK의 usr/ include에서 찾을 수 있습니다.

목록 11-19는 일반적인 마하 예외를 보여줍니다.
<<<stub이란?>>>

![11-55](../img/chapter11/11_11_55.PNG)

마찬가지로 Mach 예외 처리기인 exception_triage() (osfmk/kern/exception.c에 있음)는 예외를 Mach 메시지로 변환하는 일반적인 처리기입니다. iOS와 OS X 모두에서 프로세스가 코어 덤프로 종료 될 때마다 BSD의 proc_prepareexit(bsd/kern/kern_exit.c)의 EXC_CRASH와 함께 abnormal_exit_notify (osfmk/kern/exception.c)에서 호출됩니다. 그러나 커널의 다른 곳에서의 호출은 아키텍처에 따라 다릅니다.

i386/x64에서 i386_exception() 함수(osfmk/i386/trap.c에서)는 exception_ triage()를 호출합니다 (그림 11-8 참조). i386_exception() 자체는 여러 위치에서 호출 될 수 있습니다.

> Low level Interrupt Descriptor Table (IDT) handlers — idt.s 및 idt64.s는 CCALL3 및 CCALL5 매크로를 사용하여 커널 모드 예외에 대해 i386_ exception()을 호출합니다 (후자는 i386_exception()이 세 개만 필요하지만 5개 인수를 전달함).

> user_trap() (osfmk/i386/trap.c) — IDT 핸들러에서 자체적으로 호출 된 코드와 함께 i386_ exception()을 호출합니다.

> mach_call_munger_xx functions (i386 and x64, both in osfmk/bsd_i386.c) — 잘못된 Mach 시스템 호출에서 EXC_SYSCALL과 함께 i386_exception()을 호출합니다.

> fpextovrflt (osfmk/i386/fpu.c) — 특정 FPU 오류는 부동 소수점 프로세서가 사용자 모드 또는 커널 모드에서 메모리 액세스 오류를 생성 할 때 호출됩니다.

![11-56](../img/chapter11/11_11_56.PNG)

ARM에서는 exception_ triage()가 low-level 예외 처리기에서 직접 호출되기 때문에 동등한 arm_exception이 없는 것 같습니다.

> fleh_swi — 시스템 호출 핸들러는 유효하지 않은 시스템 호출 또는 EXC_BAD_ACCESS에서 EXC_SYSCALL과 함께 exception_triage를 호출합니다.

> sleh_undef — 정의되지 않은 명령어 핸들러인 fleh_undef에서 정의되지 않은 명령어로 호출됩니다.

> sleh_abort (called from fleh_prefabt or fleh_dataabt, for instruction prefetch or data abort handlers) — 프로세서 명령 또는 데이터 중단에서 EXC_BAD_ACCESS 코드로 exception_triage를 호출합니다.

exception_triage()는 주요 예외 로직 (마하 메시지 레벨)이 두 아키텍처에서 동일하게 작동합니다. 이 함수는 exception_deliver() (osfmk/kern/exception.c에도 있음)를 사용하여 앞에서 설명한 방식 (스레드, 작업 및 최종 호스트)으로 예외를 전달하려고 시도합니다.

호스트 자체뿐만 아니라 각 스레드 또는 Task 개체에는 예외 포트 배열이 있으며 이 포트는 초기화 (보통 IP_NULL로)되며 xxx_set_exception_ports() 호출을 사용하여 설정할 수 있습니다. 여기서 xxx는 스레드, Task 또는 호스트입니다.

앞의 두 가지는 osfmk/kern/ipc_tt.c에 정의되어 있고 후자는 ipc_host.c에 정의되어 있습니다. 그들의 프로토 타입은 모두 매우 유사합니다.

![11-57](../img/chapter11/11_11_57.PNG)

"behaviors"(표 11-12 참조)은 예외에 따라 어떤 유형의 메시지가 생성되는지에 대한 기계 독립적 표시입니다. 각 동작에는 (운영 체제에 따라 다를 수 있음) "flavor"이 있습니다.

![11-58](../img/chapter11/11_11_58.PNG)

behavior는 해당 함수에 의해 구현됩니다. EXCEPTION_DEFAULT의 경우 [mach]_exception_raise, EXCEPTION_STATE의 경우 [mach]_exception_state_raise 이고 예외 코드가 64 비트 코드인 경우에는 함수 이름이 behavior 상수(소문자임)와 동일하며 [mach] 함수가 대신 사용됩니다. 

다양한 behavior는 호스트 수준에서 하드 코드된 예외 캐처 catch_ [mach] _exception_xxx에 의해 처리됩니다. 이전과 같이 함수 이름은 behavior에 매핑됩니다 ([mach] 변형은 64 비트 mach_exception_data_t에 대한 것입니다). </bsd/uxkern/ux_exception.c>에 있는 이러한 함수는 결국 ux_exception을 호출하여 예외를 해당 UNIX 신호로 변환하고 12 장에서 설명한대로 스레드 신호로 오류 스레드에 전달합니다.

예외 포트는 OS X의 가장 중요한 기능 중 하나인 crash 리포터를 활성화하는 메커니즘입니다. launchd는 예외 포트를 등록하고 포트가 포트를 통해 상속 될 때 동일한 예외 포트가 모든 하위 항목에 적용됩니다. Launchd는 ReportCrash를 MachExceptionHandler로 설정합니다. 이렇게하면 시작된 작업에서 예외가 발생하면 필요할 때 충돌 보고기를 자동으로 시작할 수 있습니다. 디버거는 예외 포트를 사용하여 예외를 트랩하고 오류를 중단합니다. 다음 실험에서는 예외 처리 측면을 보여줍니다.

## Experiment: Mach Exception Handling

직접 예외 처리를 시도하려면 목록 11-20에 표시된 기본 예제를 코딩하십시오.

![11-59](../img/chapter11/11_11_59.PNG)

![11-60](../img/chapter11/11_11_60.PNG)

이 간단한 코드는 세 가지 선택을 제공합니다.

> No arguments : 코드는 기본 예외 처리로 실행됩니다.

> -u : UNIX 신호를 원할 경우 이것을 사용하십시오. 신호 처리기는 UNIX 신호(SIGSEGV, Segmentation Fault)를 포착합니다.

> -m : Mach 예외 처리를 원하는 경우 이를 사용하십시오. 마하 예외는 예외 포트의 특수 설정에 의해 포착됩니다.

이 코드를있는 그대로 실행하면 Mach 예외 나 결과 UNIX 신호가 포착되지 않으면 충돌이 발생합니다. -u를 사용하여 실행하면 실제로 예상대로 UNIX 신호를 포착합니다. 그러나 -m을 사용하면 코드가 충돌하지 않고 중단됩니다. 왜 그런지 생각해보십시오.


예외가 발생하여 프로그램이 정지 중이며 메시지가 등록된 예외 포트로 전송됩니다. 그러나 포트에는 활성 수신기가 없으므로 메시지가 포트에서 무한정 정지됩니다. Mach 예외 처리는 UNIX 예외 처리 전에 발생하므로 UNIX 신호가 프로세스에 도달하지 않습니다. EXC_MASK_ALL을 요청 했으므로 crash를 제로 나누기와 같은 다른 오류로 교체 할 수 있습니다. 목록 11-19에 표시된 EXC_ 상수를 실험 할 수도 있습니다.

여기에 표시된 프로그램은 쓸모가 없습니다. 예외가 발생하지만 처리는하지 않습니다. 훨씬 더 유용한 접근 방식은 예외에 대한 알림을 받을 때 실제로 무언가를 수행하는 것입니다. 이를 위해 mach_msg를 사용하여 예외 포트에서 활성 리스너를 작성하십시오. 동일한 프로그램의 다른 스레드가 이를 수행 할 수 있지만, 두 번째 프로그램이 모두 예외 처리 부분을 구현하면 더 흥미로운 효과를 얻을 수 있습니다. 이는 CrashReporter를 시작할 수 있는 launchd 프로세스의 예외 포트 등록과 유사합니다. Listing 11-20을 외부 예외 처리기로 바꾸는 데 필요한 수정 사항이 Listing 11-21에 나와있습니다.

![11-61](../img/chapter11/11_11_61.PNG)

![11-62](../img/chapter11/11_11_62.PNG)

![11-63](../img/chapter11/11_11_63.PNG)

임의의 프로그램에서이 코드를 테스트하려면 몇 초 동안 잠을 자도록 간단한 프로그램을 만든 다음 작동을 중단하십시오 (선택하십시오 : NULL 포인터 역 참조, 0 나누기 등). 프로그램이 휴면 상태 일 때 예외 처리 프로그램을 빠르게 첨부하십시오. 이 코드는 OS X 및 iOS에서 각각 출력 11-3 및 11-4와 유사한 것을 보여줍니다.

![11-64](../img/chapter11/11_11_64.PNG)

![11-65](../img/chapter11/11_11_65.PNG)

NU의 BSD 계층이 저수준 마하 예외를 잘 알려진 UNIX 신호로 변환하는 방법을 보여주는 13 장에서 예외 포트가 다시 검토됩니다.

