# <Chapter3> On the Shoulders of Giants : OS X and iOS Technologies

## BSD HEIRLOOMS
XNU의 핵심은 Mach 이지만, User Mode는 주로 BSD의 주요 인터페이스로 구성됩니다. OSX는 POSIX 호환 시스템 호출과 여러 BSD 특정 시스템 호출을 제공합니다. 경우에 따라 Apple은 몇 가지 추가 단계를 수행하여 추가 기능을 구현했으며 그 중 일부는 BSD 및 OpenDarwin으로 백-포트되었습니다.


### sysctl
sysctl 명령은 커널의 내부 상태에 액세스하는 표준화 된 방법입니다. 이 명령을 사용하여 관리자는 커널 변수 값을 직접 쿼리하여 중요한 런타임 진단을 제공 할 수 있습니다. 경우에 따라 변수 값을 수정하여 커널의 동작을 변경하는 것도 가능합니다. 

sysctl 명령은 sysctl 라이브러리 호출을 래핑합니다.이 호출은 __sysctl 시스템 호출을 래핑합니다. 내 보낸 커널 변수는 MIB (Management Information Base) 이름으로 액세스됩니다. SNMP (Simple Network Management Protocol)에서 차용 한이 명명 규칙은 변수를 네임 스페이스별로 분류합니다.

네임 스페이스 -> PDF의 테이블3-1을 참고하면된다.

이런 네임 스페이스는 정수로 표현되어 있다. 각 네임 스페이스에는 직접 정의 된 변수 (예 : kern.ostype, 1.1) 또는 하위 네임 스페이스 (예 : kern.ipc.somaxconn, 1.32.2)가 정의 될 수 있습니다. 두 경우 모두 정규화 된 이름을 지정하거나 숫자 MIB 지정자로 해당 변수에 액세스 할 수 있습니다. sysctlnametomib (3)을 사용하여 이름으로 MIB 번호를 검색 할 수 있지만 그 반대의 경우는 아닙니다. 따라서 MIB를 번호별로 걸을 수는 있지만 해당 이름을 검색 할 수는 없습니다.


### kqueues
kqueues는 커널 이벤트 알림을 위한 BSD 메커니즘입니다. kqueue는 특정 유형 및 범주의 이벤트가 발생할 때, 사용하는 블록 디스크립터입니다. 따라서 사용자(또는 커널) 모드 프로세스는 디스크립터를 기다릴 수 있어 하나 이상의 프로세스 간단하고 효과적인 방법으로 동기화(synchronization)를 할 수 있습니다.

kqueue 및 해당 kevent는 커널에서 비동기 I/O의 기초를 형성합니다 (따라서 POSIX poll (2) / select (2)를 활성화). kqueue는 인수없이 kqueue(2) 시스템 호출(# 362)을 호출하여 사용자 모드에서 구성 할 수 있습니다. 그런 다음 EV_SET 매크로를 사용하여 관심있는 특정 이벤트를 지정하면 struct kevent가 초기화됩니다. kevent (2) 또는 kevent64 (2) 시스템 호출 (각각 # 363 또는 # 369)을 호출하면 이벤트 필터가 설정되고 충족되면 반환됩니다. 시스템은 표 3-2에 표시된 것처럼 여러 개의 "사전 정의 된"필터를 지원합니다.

## Auditing
OSX에는 BSM (Basic Security Module)의 구현이 포함되어 있습니다. 이 서브 시스템은 사용자 및 프로세스 조치를 추적하는 데 유용하지만 디스크 공간 및 전체적으로 비용이 많이들 수 있습니다. 보안에 민감한 작업 인 경우 감사(Auditing)는 커널 수준에서 수행해야합니다. OSX에서는 감사(Auditing)가 Mach 메시지를 통해 구현됩니다.

### The Administrator's View
감사(Auditing)는 OSX에서 자체 포함 된 하위 시스템입니다. 데몬(daemon)은 실제로 감사(Aauditing) 로그를 기록하지 않고 커널에 의해 직접 수행됩니다. 데몬(daemon)은 커널 구성 요소를 제어하므로 데몬을 제어하는 것은 감사(auditing)를 제어하는 것과 같습니다. 이를 위해 관리자는 audit(8) 명령을 사용하여 감사를 초기화(-i) 또는 종료(-t), 새 로그를 시작(-n) 또는 만료(-e) 할 수 있습니다. 일반적으로 auditd (8)는 60 초 동안 활동이 없으면 plist TimeOut 키에 지정된대로 시간 초과됩니다. auditd (8)가 실행 중이 아니기 때문에 감사(auditing) 상태는 변화가 없게 됩니다.

~~~
*daemon : 멀티태스킹 운영체제에서 데몬은 사용자가 직접적으로 제어하지 않고, 백그라운드에서 돌면서 여러 작업을 하는 프로그램을 말한다.
~~~

감사 로그는 압축 이진 형식으로 praudit(1) 명령을 사용하여 해독 할 수 있습니다. 이 명령은 CSV나 XML과 같이 사람이 읽을 수 있고 기계가 읽을 수 있는 다양한 형식의 레코드로 인쇄 할 수 있습니다. 감사 레코드를 통한 검색을 가능하게하기 위해 auditreduce(1) 명령은 이벤트 유형(-m), 오브젝트 액세스(-o), 특정 UID(-e) 등을 기준으로 필터 레코드로 구성된 스위치 배열과 함께 사용될 수 있습니다.

로그는 자주 순환되므로 사용자 모드 프로그램이 감사 레코드에 실시간으로 액세스 할 수 있도록 특수 문자 장치(/dev/auditpipe)가 존재합니다. 따라서 praudit(1) 명령을 /dev/auditpipe에서 직접 사용할 수 있으므로 쉘 스크립트에 특히 유용합니다.

감사는 작업 시점에 수행되어야하므로 디스크 공간뿐만 아니라 시스템 성능에도 현저한 영향을 줄 수 있습니다. 따라서 관리자는 표 3-3에 나열된 / etc / security에있는 여러 파일을 사용하여 감사를 조정할 수 있습니다. (PDF에서 표 참고)

### The Programmer's View
감사가 활성화 된 경우 XNU는 표 3-4에 표시된대로 감사를 활성화 및 제어하기 위해 시스템 호출 # 350에서 # 359까지 전용합니다 (모두 성공한 경우 시스템 호출의 표준 int 반환 값을 반환합니다 : 0, -1을 설정하고 errno를 설정 함/ 표는 PDF 참고).
Apple은 BSM 표준에서 벗어난 3개의 추가 시스템 호출을 통해 서브시스템인 마하 시스템에 연결함으로써 이를 강화한다.

## Mandatory Access Control(MAC)
FreeBSD 5.x는 MAC(Mandatory Access Control)라는 강력한 보안 기능을 도입 한 최초의 기업입니다. MAC을 통해 권한뿐만 아니라 특정 프로세스에 의해 특정 파일 또는 리소스(소켓, IPC 등)에 대한 액세스 제한까지 있을 수 있습니다.

MAC의 핵심 개념은 시스템의 파일이나 객체에 사전에 정의된 분류로 라벨(Label)을 적용하는 것입니다 (스파이 영화의 “Unclassified,” “Confidential,” “Top Secret”와 같이 태그하는 것을 생각하면 됩니다.). MAC은 라벨(Label)에 적합하지 않은 모든 객체에 대해서 접근을 거부합니다. OSX는 

MAC은 레이블을 준수하지 않는 모든 객체에 대한 액세스를 거부합니다. OSX는 보안 정책을 확장하여 객체뿐만 아니라 다양한 작업에 적용이 가능하게 했습니다.

MAC은 프레임워크이며 커널의 일부일 필요는 없고 시스템 보안을 제어하기 위해 플러그인이 될 수 있습니다. MAC을 등록하면 특수한 확장 커널(kernel extension)이 보안 정책 시행을 담당합니다. 커널 측면에서 MAC에 대한 콜 아웃은 다양한 시스템 호출 구현에 삽입되므로 실제로 사용자 모드 요청을 처리하기 전에 각 시스템 호출이 MAC 유효성 검사를 먼저 통과해야합니다. MAC 계층 자체는 결정을 내리지 않고 등록된 정책 모듈을 호출합니다.

관리자는 sysctl(8)을 사용하여 다양한 하위 시스템에서 MAC 정책을 제어 할 수 있습니다. MAC은 시행 플래그를 포함하는 최상위 보안 MIB를 동적으로 등록하고 노출합니다.


## OSX AMD IOS-Specific Technologies
Mac OS는 수년 동안 여러 가지 전위 기술을 도입했으며 그 중 일부는 여전히 독점 기술입니다. 다음 섹션에서는 이러한 기술, 특히 운영 체제 관점에서 관심있는 기술에 대해 설명합니다.

## User and Group Management(OSX)
UNIX는 오래된 암호 파일에 의존하지만, 여전히 단일 사용자 모드에는 /etc/master.passwd라는 새도우 파일을 사용합니다. 그러나 OSX는 자체 디렉토리 서비스인 DirectoryService 사용하여 더 이상 암호파일을 사용하지 않습니다. 이 서비스는 Lion에서는 opendirectoryd로 이름이 변경되었습니다.

데몬(daemon)의 새로운 이름은 그 성격을 반영합니다. OpenLDAP 프로젝트의 구현입니다.

LDAP(Lightweight Directory Access Protocol)와 같은 표준 프로토콜을 사용하면 Microsoft의 Active Directory와 같은 Apple 이외의 디렉토리 서비스와 통합 할 수 있습니다. 디렉토리 서비스는 사용자 및 그룹을 유지하는 것 이외에도 시스템 설정(구성)의 다른 측면을 담당합니다. OSX는 데몬과 인터페이스하기 위해 dscl(8)이라는 Command Line 유틸리티를 제공합니다. 이 도구를 사용하여 시스템의 사용자 및 그룹을 표시 할 수 있습니다.

OSX Lion의 초기 보안 취약점 중 하나는 dscl(8)을 사용하여 루트가 아닌 사용자가 기존 비밀번호를 몰라도 사용자의 비밀번호를 변경할 수 있다는 것입니다. 이런 문제는 OSX의 지속적인 업데이트로 보안 문제가 해결되었습니다.

## System Configuration
OSX는 시스템 구성을 위해 특수 데몬을 사용합니다(___configd(8)___). 이 데몬은 /System/Library/SystemConfiguration/ 디렉토리에 있는 추가로드 가능한 번들(___"플러그인"___)을 로드 할 수 있으며 여기에는 IP 및 IPv6 구성, 로깅 및 기타 번들이 포함됩니다. 시스템 환경설정 및 응용 프로그램 설정은 그래픽 프론트 엔드로 사용할 수 있기 때문에 일반 사용자는 이를 잘 모르고 있습니다.

공용 SystemConfiguration.framework를 사용하면 시스템 구성에 프로그래밍 방식으로 액세스 할 수 있습니다. OSX의 pmset(1) 명령어는 전원 관리 설정을 구성하는 프레임 워크와 연결됩니다. 이 프로그램에 의해 버려지는 것은 plist 파일로 유지됩니다. 이런 파일은 /Library/Preferences/SystemConfiguration 경로에 디폴트로 저장도비니다. 해당 프로그램의 출력과 디렉토리의 preferences.plist 파일의 출력과 비교하면 일치하는 것을 볼 수 있습니다.

## Logging
BSD 기반 플랫폼으로 이동하면서 OSX는 UNIX 시스템 로그에 대한 지원도 상속했습니다. 이 지원은 일반적으로 syslogd(8) 라고하는 오래된 메커니즘과 완전히 호환됩니다. 

syslog 메커니즘은 간단히 말해서 메시지 facility와 severity로 분류된 문자 메시지를 처리합니다.  다양한 UNIX 하위 시스템 (메일, 인쇄 등)에는 커널 (LOG_KERN)과 마찬가지로 고유한 기능이 있습니다. severity는 LOG_DEBUG 및 LOG_INFO (“파일 열기”), LOG_ERR (“파일을 열 수 없음”), LOG_CRIT (“잘못된 섹터입니까?”), LOG_ALERT (“안녕하세요, 디스크는 어디에 있습니까?”), LOG_EMERG (“Meltdown imminent!”)까지 있습니다. 
관리자는 /etc/syslog.conf 구성 파일을 사용하여 facility/severity 조합에 따라 수행 할 작업을 결정할 수 있습니다.

프로그래머는 syslog(3) API를 사용하여 syslog(3) API를 사용하여 syslog ()에 대한 호출 (구성된 이름, 기능 및 기타 옵션 지정)로 구성된 syslog ()를 통해 syslog와 인터페이스합니다. syslog 데몬은 UNIX 도메인 소켓 (전통적으로 / dev / log, OS X에서는 / var / run / syslog로 변경되었지만)을 통해 메시지를 가로 챕니다.

OS X 10.4(Tiger)는 Apple System Log 또는 ASL이라는 새로운 로깅 모델을 도입했습니다. 이 새로운 아키텍처(iOS에서도 사용됨)는 syslog가 제공하는 것보다 더 많은 유연성을 제공하는 것을 목표로 합니다. ASL은 수준과 심각도가 동일한 syslog를 모델로 하지만 syslog에서 제공하지 않는 필터링 및 검색과 같은 더 많은 기능을 허용합니다.

~~~
* facility : 메시지를 발생시킨 프로그램의 타입을 나타내는 값
* severity : 메시지의 성격 또는 중요도를 나타낸다.
* 로깅 : 시스템 동작 시 시스템 상태/작동 정보를 시간의 경과에 따라 기록하는 것
* 로그 : 시스템 동작 시 시스템 상태/작동 정보와 같은 기록
~~~

## Apple Events and AppleScript
OSX의 강력한 기능 중 하나는 스크립트 기능입니다. AppleScript는 osascript 명령과 Automator를 바탕으로 강력한 메커니즘이되었습니다. AppleScript는 어느 정도 문법적인 요소가 존재하며, 이를 잘 활용하면 OSX 내장 어플리케이션을 완전 자동화 할 수 있습니다. 

AppleScript는 AppleEvents 메커니즘을 사용합니다. AppleScript는 AppleTalk 프로토콜 또는 TCP/IP를 통해 원격 호스트로 확장 될 수 있습니다. 후자의 경우, 이 프로토콜은 “eppc” 라고하며 TCP포트 3031을 사용하는 독점 프로토콜입니다. 원격 기능은 시스템 환경 설정의 공유 애플릿에서 원격 Apple 이벤트가 활성화 된 경우에만 활성화됩니다. 이것은 launchd (8)에게 eppc 포트에서 수신하도록 요청하고 요청이 수신되면 AppleEvents 서버 인 AEServer (CoreServices 내부의 AE.framework의 Support/ 디렉토리에 있음)를 시작합니다. launchd (8)는 /System/Library/LaunchDaemons 의 해당 plist 파일에서 많은 주문형 서비스를 시작합니다. AEServer는 com.apple.eppc.plist입니다.

AppleScript는 작업 자동화를위한 훌륭한 메커니즘입니다.

두 가지 간단한 환경 변수인 AEDebugSends 및 AEDebugReceives를 통해 Apple Events 에서 진행되는 작업을 쉽게 확인할 수 있습니다. 그런 다음 osascript (또는 경우에 따라 Automator)를 사용하면 많은 출력이 생성됩니다.

## FSEvents
모든 최신 운영 체제는 개발자에게 파일 시스템 알림을 위한 API를 제공합니다. 이를 통해 사용자 프로그램에서 파일의 추가, 수정, 삭제에 대해 빠르고 쉬운 응답이 가능합니다. Windows에는 MJ_DIRECTORY_CONTROL이 있고 Linux에는 inotify 가 있습니다. Mac OSX는 FSEvents를 제공합니다.

FSEvent는 개념적으로 리눅스의 inotify와 유사합니다. 프로세스 (또는 스레드)는 파일 디스크립터(descriptor)를 가져와서 그로부터 read(2)를 시도한다. 시스템 호출은 일부 이벤트가 발생할 때까지 차단됩니다.이 때 수신 된 버퍼에는 프로그램이 어떤 일이 일어 났는지 알 수 있는 이벤트 세부정보가 포함 된 다음 그에 따라 작동합니다(예 : 파일 브라우저에 새 아이콘 표시).

그러나 FSEvents는 inotify보다 더 복잡합니다. -> FSEvents의 작동 원리입니다.
* 프로세스(또는 스레드)는 FSEvents에 대한 핸들을 얻도록 요청합니다. 이는 pseudo-device(/dev/fsevents)입니다.
* 그런 다음 요청자(requestor)는 ioctl(2)인 FSEVENTS_CLONE을 실행합니다. ioctl을 사용하면 특정 이벤트에 대한 필터링이 가능하여 관심있는 이벤트의 특정 파일과 특정 작업만 전달 받을 수 있습니다. FSEvents는 커널의 파일 시스템 처리 논리 (VFS, 가상 파일 시스템 스위치)에 연결되어 있기 때문에 이러한 이벤트를 지원할 수 있습니다. 복제된 파일 descriptor에서 지원되는 모든 이벤트는 보류된 알람으로 추가됩니다.
* 요청자(requestor)는 ioctl(2)을 사용하여 알림에서 요청한 정확한 이벤트 세부 정보를 수정할 수 있습니다. 정의된 제어 코드에는 FSEVENTS_WANT_COMPACT_EVENTS(정보를 더 적게 얻기 위해), FSEVENTS_WANT_EXTENDED_INFO(더 많은 정보를 얻기 위해), NEW_FSEVENTS_ DEVICE_FILTER (요청자가 관심이 없는 장치를 거르기 위해)가 포함됩니다.
* 그런 다음 요청자는 read(2) 루프를 시작합니다. 시스템 호출이 리턴 될 때마다 사용자 제공 버퍼를 이벤트 레코드 배열로 채웁니다. 한 번의 작업으로 여러 레코드를 리턴하여 읽기가 까다로울 수 있습니다. 커널 버퍼가 초과되어 이벤트가 삭제 된 경우, 특수 이벤트 (FSE_ EVENTS_DROPPED)가 이벤트 레코드에 추가됩니다.

Apple의 설명서, 설명서 페이지 또는 포함 파일을 확인하면 관련 내용이 없습니다. <sys/fsevents.h>는 FSEvents가 소개된 이후로 더 이상 사용되지 않습니다. API가 공개로 유지되더라도 3개의 주요 사용자 만 있기 때문입니다.

* coreservicesd : 시작 및 기타 서비스와 같은 핵심 서비스를 지원하는 Apple 내부 데몬입니다. 
* mds : Spotlight 서버. Spotlight는 FSEvents를 "heavy"사용자로, 새 파일을 찾고 색인화하기 위한 알림에 의존합니다. 
* fseventsd : CoreServices 프레임 워크를 사용하는 일반적인 사용자 공간의 데몬입니다.

Objective-C 및 C 애플리케이션 모두 FSEventStreamCreate에 있는 CoreServices Framework (Carbon) API를 사용할 수 있습니다. 이 프레임 워크는 실제 메커니즘 위에 있는 얇은 계층으로, RunLoop 모델, 이벤트 및 콜백을 API로 통합 할 수 있습니다.본질적으로 이것은 이벤트 중심의 동기 모델에서 비동기로 바꾸는 블로킹을 변환하는 것과 관련이 있습니다. 

## Notification
OSX은 시스템 전체 알림 메커니즘을 제공합니다. 프로세스가 이벤트를 broadcast 하거나 listen 할 수 있는  분산 IPC의 한 형태입니다. 이 메커니즘의 핵심은 부팅시 시작되는 notifyd(8) 데몬입니다. 이것은 Darwin 알림 서버입니다. 추가 데몬인 distnoted(8)는 분산 알림 서버로 작동합니다. 응용 프로그램은 notify(3) API를 사용하여 데몬과 메시지를 주고 받을 수 있습니다. 메시지는 충돌을 피하기 위해 DNS 이름을 뒤집어서 사용하는 것이 좋습니다.

API는 여러 방법 중 하나를 이용해 알림을 요청할 수 있습니다. 잘 문서화 된 <notify.h>에는 UNIX 신호, Mach 포트 및 파일 디스크립터를 통한 알림을 활성화하는 기능이 나열되어 있습니다. Client는 알림을 수동으로 일시 중지하거나 다시 시작할 수도 있습니다. notifyd(8)는 기본적으로 Mach 메시지를 사용하고 apple.system.notification_center.com의 Mach 포트를 등록하여 대부분의 알림을 처리합니다. 

notifyd(8)의 흥미로운 기능은 Apple의 파일 포트 API를 사용되는 몇 안되는 데몬 중 하나라는 것입니다. 이를 통해 파일 descriptor가 Mach 메시지를 통해 전달 될 수 있습니다.

## Addition APIs of interest
* Grand Central Dispatch : pthread API 위에 구축 된 작업 대기열 확장을 사용한 병렬화를 위한 시스템 프레임 워크.
* Launch Daemon : Mach 부트 스트랩 서버와 함께 많은 UNIX 시스템에서 융합된 데몬.
* XPC : 프로세스 간 권한 분리를 가능하게하는 고급 IPC를 위한 프레임 워크 
* kdebug : 시스템 호출 및 마하 트랩을 커널 수준에서 추적을 위한 요소.
* Systme sockets : 커널 모드의 컴포넌트와 통신 할 수 있는 PF_SYSTEM이름의 소켓
* Mach API : 상위 수준의 BSD/POSIX 인터페이스와 일치하는 기능을 제공하는 XNU의 Mach 코어에 직접 접근가능한 인터페이스.
* IOKit API : 장치 드라이버와 통신하기 위한 API로, 다양한 진단 정보와 사용자 모드에서 드라이버를 제어하는 ​​강력한 기능을 제공합니다.

## OSX And Ios Security Mechanisms
OSX에서는 바이러스와 맬웨어(malware)가 드뭅니다. 많은 사람이 주로 Windows를 사용하기 때문입니다. 스스로 악의적인 Malware를 개발한다면 전 세계 90% 이상 점유하는 것과 5% 미만 점유하는 것 중 어느 것을 공격하는데 시간과 노력을 투자 하시겠습니까?

OSX는 악성코드 “개발자”로부터 많은 관심을 끌지 못했기 때문에 안전할 수 있었습니다. 혹은 UNIX에서 기본적으로 유저가 root에 접근하지 못하는 것처럼 항상 최소 권한만을 허용하기 때문에 안전했습니다.하지만 OSX의 시장 점유가 꾸준히 증가하면서 많은 Malware가 등장하고 있으며, 애플은 꾸준히 업데이트를 진행하고 있습니다.


## Code Signing
소프트웨어를 보호하기 전에 원본을 인증해야 합니다. 인터넷의 임의의 사이트에서 앱을 다운로드하면 실제로 malware일 위험이 있습니다. 그러나 소프트웨어의 출처를 확인할 수 있고 전송 중에 수정되지 않았음을 확인 할 수 있으면 위험이 크게 줄어듭니다. 코드 서명은 이를 위한 메커니즘을 제공합니다. 

Apple은 SSL을 사용하여 웹 사이트의 아이덴티티를 설정하고 사용한 동일한 인증서를 사용하여 (발급자의 개인키로 공개키에 서명함으로써) 개발자가 응용 프로그램에 서명하고 아이덴티티를 인증하도록 권장합니다. 
디지털 서명의 핵심은 서명자의 공개키가 검증자에게 우선적으로 알려 져야한다는 것입니다. Apple은 해당 인증서를 OSX와 iOS의 키 체인에 모두 포함하며 사실상 유일한 방법입니다. (출력 3-7)에 표시된 것처럼 많은 다른 기능과 함께 시스템 키체인을 덤프 할 수있는 security(1) 유틸리티를 사용하여 이를 쉽게 확인할 수 있습니다.

Apple은 csreq(1) 명령어를 통해 확인 할 수 있는 코드서명(Code Signing)을 정의하기 위해 새로운 언어를 개발하였다. 또한, Apple은 개발자가 앱에 서명하고 기존 서명을 확인/표시 할 수 있는 codesign(1)를 제공하였다. 하지만 codesign(1)은 애플의 개발자 프로그램에 등록하면 받을 수 있는 인증서 없이는 서명할 수 없습니다.

OSX 코드 서명은 선택 사항이지만 iOS에서는 매우 필수적입니다. 서명되지 않은 응용 프로그램이 파일 시스템으로 전달되는 경우, 응용 프로그램을 실행하면 커널에 의해 종료됩니다. 시스템은 서명되지 않은 코드의 실행을 거부하기 때문에 서명된 기존 응용 프로그램의 취약점을 악용하는 것이 유일한 방법입니다.

코드 서명된 응용 프로그램은 악성 프로그램일 수 있습니다. 그러나 서비스 약관을 위반하는 모든 응용 프로그램은 Mac/iOS App Stores에서 신속하게 금지될 것입니다. Apple에 응용 프로그램을 등록하면 개인 정보를 공개해야하므로 악의적인 개발자는 소송의 대상이 될 수 있습니다. 그렇기 때문에 App Store에서 / bin/bash를 생성하거나 해당 기능을 모방하려는 악성 앱을 찾을 수 없습니다.

## Compartmentalization(Sandboxing)
구분화는 애플의 필수적인 부분이 되었습니다. 이 개념은 간단하면서도 중요한 응용 프로그램 보안 원칙입니다. 신뢰할 수 없는 응용 프로그램은 구분된 지역에서 효과적으로 실행되어야합니다. 격리된 환경에서의 작업은 제한됩니다. 레오파드에서 안전벨트로 불렸던 메커니즘은 이후에 샌드박스(SandBox)로 이름이 바뀌었습니다. 타이트한 샌드박스의 장점은 정의된 profile 범위를 벗어나서 숨겨진 악성코드가 무엇을 하는지에 대한 두려움 없이 샌드박스에서 신뢰할 수 없는 응용 프로그램을 실행할 수 있다는 것입니다. 또한, 애플은 Mac App Store의 앱을 샌드박스 형태로 제작해야 합니다.


### Enforcing the Sandbox
XNU는 샌드박스 환경을 유지하기 위해 많은 노력을 기울였습니다. 
사용자 모드에서 많은 연결과 사용으로 샌드박스는 필수입니다.
BSD MAC 계층은 샌드 박스와 권한이 모두 작동하는 메커니즘입니다.
특정 프로세스에 정책이 적용되는 경우, MAC 계층에서 정책모듈(특수 kernel extension) 중 하나를 호출하기 때문입니다. 샌드박스를 담당하는 기본 커널 확장은 sandbox.kext입니다. 언급한 바와 같이 샌드박스에는 전용 확장 데몬은 /usr/libexec/sandboxd가 있습니다. 이 데몬은 사용자 모드에서 실행하여 커널 확장에 대한 추적 및 도우미 서비스를 제공하고 요청시 시작됩니다(sandbox-exec를 사용하는지 확인할 수 있음).

(3-2 OSX Sandbox Architecture) -> PDF에서 참고
